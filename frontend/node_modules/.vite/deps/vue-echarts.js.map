{
  "version": 3,
  "sources": ["../../vue-echarts/src/composables/api.ts", "../../vue-echarts/src/composables/autoresize.ts", "../../vue-echarts/src/composables/loading.ts", "../../vue-echarts/src/utils.ts", "../../vue-echarts/src/composables/slot.ts", "../../vue-echarts/src/wc.ts", "../../vue-echarts/src/update.ts", "../../vue-echarts/src/style.css?raw", "../../vue-echarts/src/style.ts", "../../vue-echarts/src/ECharts.ts", "../../vue-echarts/src/index.ts"],
  "sourcesContent": ["import type { Ref } from \"vue\";\nimport type { EChartsType } from \"../types\";\n\nconst METHOD_NAMES = [\n  \"getWidth\",\n  \"getHeight\",\n  \"getDom\",\n  \"getOption\",\n  \"resize\",\n  \"dispatchAction\",\n  \"convertToPixel\",\n  \"convertFromPixel\",\n  \"containPixel\",\n  \"getDataURL\",\n  \"getConnectedDataURL\",\n  \"appendData\",\n  \"clear\",\n  \"isDisposed\",\n  \"dispose\",\n] as const;\n\ntype MethodName = (typeof METHOD_NAMES)[number];\n\nexport type PublicMethods = Pick<EChartsType, MethodName>;\n\nexport function usePublicAPI(\n  chart: Ref<EChartsType | undefined>,\n): PublicMethods {\n  function makePublicMethod<T extends MethodName>(name: T): EChartsType[T] {\n    // Return a function that matches the signature of EChartsType[T]\n    const fn = function (this: unknown, ...args: unknown[]): unknown {\n      if (!chart.value) {\n        throw new Error(\"ECharts is not initialized yet.\");\n      }\n      // Use Reflect.apply to call the method with proper context\n      return Reflect.apply(chart.value[name], chart.value, args);\n    };\n    return fn as EChartsType[T];\n  }\n\n  // Build the methods object with proper typing\n  const methods = METHOD_NAMES.reduce(\n    (acc, name) => {\n      acc[name] = makePublicMethod(name);\n      return acc;\n    },\n    {} as Record<MethodName, unknown>,\n  ) as PublicMethods;\n\n  return methods;\n}\n", "import { watch } from \"vue\";\nimport { throttle } from \"echarts/core\";\n\nimport type { Ref, PropType } from \"vue\";\nimport type { EChartsType, AutoResize } from \"../types\";\n\nexport function useAutoresize(\n  chart: Ref<EChartsType | undefined>,\n  autoresize: Ref<AutoResize | undefined>,\n  root: Ref<HTMLElement | undefined>,\n): void {\n  watch(\n    [root, chart, autoresize],\n    ([root, chart, autoresize], _, onCleanup) => {\n      let ro: ResizeObserver | null = null;\n\n      if (root && chart && autoresize) {\n        const { offsetWidth, offsetHeight } = root;\n        const autoresizeOptions = autoresize === true ? {} : autoresize;\n        const { throttle: wait = 100, onResize } = autoresizeOptions;\n\n        let initialResizeTriggered = false;\n\n        const callback = () => {\n          chart.resize();\n          onResize?.();\n        };\n\n        const resizeCallback = wait ? throttle(callback, wait) : callback;\n\n        ro = new ResizeObserver(() => {\n          // We just skip ResizeObserver's initial resize callback if the\n          // size has not changed since the chart is rendered.\n          if (!initialResizeTriggered) {\n            initialResizeTriggered = true;\n            if (\n              root.offsetWidth === offsetWidth &&\n              root.offsetHeight === offsetHeight\n            ) {\n              return;\n            }\n          }\n\n          // Skip if container has zero size\n          if (root.offsetWidth === 0 || root.offsetHeight === 0) {\n            return;\n          }\n\n          resizeCallback();\n        });\n        ro.observe(root);\n      }\n\n      onCleanup(() => {\n        if (ro) {\n          ro.disconnect();\n          ro = null;\n        }\n      });\n    },\n  );\n}\n\nexport const autoresizeProps = {\n  autoresize: [Boolean, Object] as PropType<AutoResize>,\n};\n", "import { inject, computed, watchEffect, toValue } from \"vue\";\n\nimport type { Ref, InjectionKey, PropType } from \"vue\";\nimport type {\n  EChartsType,\n  LoadingOptions,\n  LoadingOptionsInjection,\n} from \"../types\";\n\nexport const LOADING_OPTIONS_KEY: InjectionKey<LoadingOptionsInjection> =\n  Symbol();\n\nexport function useLoading(\n  chart: Ref<EChartsType | undefined>,\n  loading: Ref<boolean | undefined>,\n  loadingOptions: Ref<LoadingOptions | undefined>,\n): void {\n  const defaultLoadingOptions = inject(LOADING_OPTIONS_KEY, {});\n  const realLoadingOptions = computed(() => ({\n    ...toValue(defaultLoadingOptions),\n    ...loadingOptions?.value,\n  }));\n\n  watchEffect(() => {\n    const instance = chart.value;\n    if (!instance) {\n      return;\n    }\n\n    if (loading.value) {\n      instance.showLoading(realLoadingOptions.value);\n    } else {\n      instance.hideLoading();\n    }\n  });\n}\n\nexport const loadingProps = {\n  loading: Boolean,\n  loadingOptions: Object as PropType<LoadingOptions>,\n};\n", "import { warn as vueWarn } from \"vue\";\n\ntype Attrs = Record<string, any>;\n\nexport function isBrowser(): boolean {\n  return typeof window !== \"undefined\" && typeof document !== \"undefined\";\n}\n\n// Copied from\n// https://github.com/vuejs/vue-next/blob/5a7a1b8293822219283d6e267496bec02234b0bc/packages/shared/src/index.ts#L40-L41\nconst onRE = /^on[^a-z]/;\nexport const isOn = (key: string): boolean => onRE.test(key);\n\nexport function omitOn(attrs: Attrs): Attrs {\n  const result: Attrs = {};\n  for (const key in attrs) {\n    if (!isOn(key)) {\n      result[key] = attrs[key];\n    }\n  }\n\n  return result;\n}\n\nexport function isValidArrayIndex(key: string): boolean {\n  const num = Number(key);\n  return (\n    Number.isInteger(num) &&\n    num >= 0 &&\n    num < Math.pow(2, 32) - 1 &&\n    String(num) === key\n  );\n}\n\nexport function isSameSet<T>(a: T[], b: T[]): boolean {\n  const setA = new Set(a);\n  const setB = new Set(b);\n\n  if (setA.size !== setB.size) {\n    return false;\n  }\n\n  for (const val of setA) {\n    if (!setB.has(val)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport function isPlainObject(v: unknown): v is Record<string, unknown> {\n  return v != null && typeof v === \"object\" && !Array.isArray(v);\n}\n\nconst LOG_PREFIX = \"[vue-echarts]\";\n\nexport function warn(message: string): void {\n  vueWarn(`${LOG_PREFIX} ${message}`);\n}\n", "import {\n  h,\n  Teleport,\n  onUpdated,\n  onUnmounted,\n  onMounted,\n  shallowRef,\n  shallowReactive,\n} from \"vue\";\nimport type { Slots, SlotsType } from \"vue\";\nimport type { Option } from \"../types\";\nimport { isBrowser, isValidArrayIndex, isSameSet, warn } from \"../utils\";\nimport type { TooltipComponentFormatterCallbackParams } from \"echarts\";\n\nconst SLOT_OPTION_PATHS = {\n  tooltip: [\"tooltip\", \"formatter\"],\n  dataView: [\"toolbox\", \"feature\", \"dataView\", \"optionToContent\"],\n} as const;\ntype SlotPrefix = keyof typeof SLOT_OPTION_PATHS;\ntype SlotName = SlotPrefix | `${SlotPrefix}-${string}`;\ntype SlotRecord<T> = Partial<Record<SlotName, T>>;\nconst SLOT_PREFIXES = Object.keys(SLOT_OPTION_PATHS) as SlotPrefix[];\n\nfunction isValidSlotName(key: string): key is SlotName {\n  return SLOT_PREFIXES.some(\n    (slotPrefix) => key === slotPrefix || key.startsWith(slotPrefix + \"-\"),\n  );\n}\n\nexport function useSlotOption(slots: Slots, onSlotsChange: () => void) {\n  const detachedRoot = isBrowser() ? document.createElement(\"div\") : undefined;\n  const containers = shallowReactive<SlotRecord<HTMLElement>>({});\n  const initialized = shallowReactive<SlotRecord<boolean>>({});\n  const params = shallowReactive<SlotRecord<unknown>>({});\n  const isMounted = shallowRef(false);\n\n  // Teleport the slots to a detached root\n  const teleportedSlots = () => {\n    // Make slots client-side only to avoid SSR hydration mismatch\n    return isMounted.value && detachedRoot\n      ? h(\n          Teleport,\n          { to: detachedRoot },\n          Object.entries(slots)\n            .filter(([key]) => isValidSlotName(key))\n            .map(([key, slot]) => {\n              const slotName = key as SlotName;\n              const slotContent = initialized[slotName]\n                ? slot?.(params[slotName])\n                : undefined;\n              return h(\n                \"div\",\n                {\n                  ref: (el) => {\n                    if (el instanceof HTMLElement) {\n                      containers[slotName] = el;\n                    }\n                  },\n                  style: { display: \"contents\" },\n                },\n                slotContent,\n              );\n            }),\n        )\n      : undefined;\n  };\n\n  // Helper to check if a value is a plain object\n  function isObject(val: unknown): val is Record<string, unknown> {\n    return val !== null && typeof val === \"object\" && !Array.isArray(val);\n  }\n\n  // Shallow-clone the option along each path and override the target callback\n  function patchOption(src: Option): Option {\n    const root = { ...src } as Record<string, unknown>;\n\n    // Ensure the child at `seg` is a writable container (cloned or newly created).\n    // Returns the child container, or undefined if traversal is blocked by a primitive.\n    const ensureChild = (\n      parent: Record<string, unknown>,\n      seg: string,\n    ): Record<string, unknown> | undefined => {\n      const next = parent[seg];\n\n      if (Array.isArray(next)) {\n        parent[seg] = [...next];\n        return parent[seg] as Record<string, unknown>;\n      }\n      if (isObject(next)) {\n        parent[seg] = { ...next };\n        return parent[seg] as Record<string, unknown>;\n      }\n      if (next === undefined) {\n        parent[seg] = isValidArrayIndex(seg) ? [] : {};\n        return parent[seg] as Record<string, unknown>;\n      }\n      // Blocked by a non-container value\n      return undefined;\n    };\n\n    Object.keys(slots)\n      .filter((key) => {\n        const valid = isValidSlotName(key);\n        if (!valid) {\n          warn(`Invalid slot name: ${key}`);\n        }\n        return valid;\n      })\n      .forEach((key) => {\n        const [prefix, ...rest] = key.split(\"-\") as [SlotPrefix, ...string[]];\n        const tail = SLOT_OPTION_PATHS[prefix];\n        if (!tail) {\n          return;\n        }\n\n        const path = [...rest, ...tail];\n        if (path.length === 0) {\n          return;\n        }\n\n        // Traverse to the parent of the leaf, cloning or creating along the way\n        let cur: Record<string, unknown> | undefined = root;\n        for (let i = 0; i < path.length - 1; i++) {\n          cur = ensureChild(cur, path[i]);\n          if (!cur) {\n            return; // Blocked by a primitive â€” skip this key\n          }\n        }\n\n        cur[path[path.length - 1]] = (p: unknown) => {\n          initialized[key] = true;\n          params[key] = p;\n          return containers[key];\n        };\n      });\n\n    return root as Option;\n  }\n\n  // `slots` is not reactive, so we need to watch it manually\n  let slotNames: SlotName[] = [];\n  onUpdated(() => {\n    const newSlotNames = Object.keys(slots).filter(isValidSlotName);\n    if (!isSameSet(newSlotNames, slotNames)) {\n      // Clean up states for removed slots\n      slotNames.forEach((key) => {\n        if (!newSlotNames.includes(key)) {\n          delete params[key];\n          delete initialized[key];\n          delete containers[key];\n        }\n      });\n      slotNames = newSlotNames;\n      onSlotsChange();\n    }\n  });\n\n  onMounted(() => {\n    isMounted.value = true;\n  });\n\n  onUnmounted(() => {\n    detachedRoot?.remove();\n  });\n\n  return {\n    teleportedSlots,\n    patchOption,\n  };\n}\n\nexport type SlotsTypes = SlotsType<\n  Record<\n    \"tooltip\" | `tooltip-${string}`,\n    TooltipComponentFormatterCallbackParams\n  > &\n    Record<\"dataView\" | `dataView-${string}`, Option>\n>;\n", "import { isBrowser } from \"./utils\";\n\nlet registered: boolean | null = null;\n\nexport const TAG_NAME = \"x-vue-echarts\";\n\nexport interface EChartsElement extends HTMLElement {\n  __dispose: (() => void) | null;\n}\n\nexport function register(): boolean {\n  if (registered != null) {\n    return registered;\n  }\n\n  const registry = globalThis.customElements;\n\n  if (!isBrowser() || !registry?.get) {\n    registered = false;\n    return registered;\n  }\n\n  if (!registry.get(TAG_NAME)) {\n    try {\n      class ECElement extends HTMLElement implements EChartsElement {\n        __dispose: (() => void) | null = null;\n\n        disconnectedCallback(): void {\n          if (this.__dispose) {\n            this.__dispose();\n            this.__dispose = null;\n          }\n        }\n      }\n\n      registry.define(TAG_NAME, ECElement);\n    } catch {\n      registered = false;\n      return registered;\n    }\n  }\n\n  registered = true;\n  return registered;\n}\n", "import type { Option } from \"./types\";\nimport { isPlainObject } from \"./utils\";\n\nexport interface UpdatePlan {\n  notMerge: boolean;\n  replaceMerge?: string[];\n}\n\n/** Summary of a top-level array key for deletion detection. */\nexport interface ArraySummary {\n  /** Unique, sorted string ids extracted from items' `id` field. */\n  idsSorted: string[];\n  /** Count of items without an `id` field. */\n  noIdCount: number;\n}\n\n/** Minimal signature of an option used to decide setOption behavior. */\nexport interface Signature {\n  /** Lengths of `option.options` and `option.media` (0 if not arrays). */\n  optionsLength: number;\n  mediaLength: number;\n  /** Map of array-typed top-level keys to their summaries. */\n  arrays: Record<string, ArraySummary | undefined>;\n  /** Sorted list of object-typed top-level keys. */\n  objects: string[];\n  /** Sorted list of scalar-typed top-level keys (string|number|boolean|null). */\n  scalars: string[];\n}\n\n/**\n * Read an item's `id` as a string.\n * Only accept string or number. Other types are ignored to surface inconsistent data early.\n */\nfunction readId(item: unknown): string | undefined {\n  if (!isPlainObject(item)) {\n    return undefined;\n  }\n  const raw = (item as { id?: unknown }).id;\n  if (typeof raw === \"string\") {\n    return raw;\n  }\n  if (typeof raw === \"number\" && Number.isFinite(raw)) {\n    return String(raw);\n  }\n  return undefined;\n}\n\n/**\n * Build a minimal signature from a full ECharts option.\n * Only top-level keys are inspected.\n */\nexport function buildSignature(option: Option): Signature {\n  const opt = option as Record<string, unknown>;\n\n  const optionsLength = Array.isArray(opt.options)\n    ? (opt.options as unknown[]).length\n    : 0;\n  const mediaLength = Array.isArray(opt.media)\n    ? (opt.media as unknown[]).length\n    : 0;\n\n  const arrays: Record<string, ArraySummary | undefined> = Object.create(null);\n  const objects: string[] = [];\n  const scalars: string[] = [];\n\n  for (const key of Object.keys(opt)) {\n    if (key === \"options\" || key === \"media\") {\n      continue;\n    }\n\n    const value = opt[key];\n\n    if (Array.isArray(value)) {\n      const items = value as unknown[];\n      const ids = new Set<string>();\n      let noIdCount = 0;\n\n      for (let i = 0; i < items.length; i++) {\n        const id = readId(items[i]);\n        if (id !== undefined) {\n          ids.add(id);\n        } else {\n          noIdCount++;\n        }\n      }\n\n      const idsSorted = ids.size > 0 ? Array.from(ids).sort() : [];\n\n      arrays[key] = { idsSorted, noIdCount };\n    } else if (isPlainObject(value)) {\n      objects.push(key);\n    } else {\n      // scalar: string | number | boolean | null  (undefined is treated as \"absent\")\n      if (value !== undefined) {\n        scalars.push(key);\n      }\n    }\n  }\n\n  if (objects.length > 1) {\n    objects.sort();\n  }\n  if (scalars.length > 1) {\n    scalars.sort();\n  }\n\n  return { optionsLength, mediaLength, arrays, objects, scalars };\n}\n\nfunction diffKeys(\n  prevKeys: readonly string[],\n  nextKeys: readonly string[],\n): string[] {\n  if (prevKeys.length === 0) {\n    return [];\n  }\n  if (nextKeys.length === 0) {\n    return prevKeys.slice();\n  }\n\n  const nextSet = new Set(nextKeys);\n  const missing: string[] = [];\n\n  for (let i = 0; i < prevKeys.length; i++) {\n    const key = prevKeys[i];\n    if (!nextSet.has(key)) {\n      missing.push(key);\n    }\n  }\n\n  return missing;\n}\n\nfunction hasMissingIds(\n  prevIds: readonly string[],\n  nextIds: readonly string[],\n): boolean {\n  if (prevIds.length === 0) {\n    return false;\n  }\n  if (nextIds.length === 0) {\n    return true;\n  }\n\n  const nextSet = new Set(nextIds);\n  for (let i = 0; i < prevIds.length; i++) {\n    if (!nextSet.has(prevIds[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport interface PlannedUpdate {\n  option: Option;\n  signature: Signature;\n  plan: UpdatePlan;\n}\n\n/**\n * Produce an update plan plus a normalized option that encodes common deletions.\n * Falls back to `notMerge: true` when the change looks complex.\n */\nexport function planUpdate(\n  prev: Signature | undefined,\n  option: Option,\n): PlannedUpdate {\n  const next = buildSignature(option);\n\n  if (!prev) {\n    return { option, signature: next, plan: { notMerge: false } };\n  }\n\n  if (next.optionsLength < prev.optionsLength) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n  if (next.mediaLength < prev.mediaLength) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n\n  if (diffKeys(prev.scalars, next.scalars).length > 0) {\n    return { option, signature: next, plan: { notMerge: true } };\n  }\n\n  const replace = new Set<string>();\n  const overrides = new Map<string, null | []>();\n\n  const missingObjects = diffKeys(prev.objects, next.objects);\n  for (let i = 0; i < missingObjects.length; i++) {\n    overrides.set(missingObjects[i], null);\n  }\n\n  for (const key of Object.keys(prev.arrays)) {\n    const prevArray = prev.arrays[key];\n    if (!prevArray) {\n      continue;\n    }\n\n    const nextArray = next.arrays[key];\n\n    if (!nextArray) {\n      if (prevArray.idsSorted.length > 0 || prevArray.noIdCount > 0) {\n        overrides.set(key, []);\n        replace.add(key);\n      }\n      continue;\n    }\n\n    if (hasMissingIds(prevArray.idsSorted, nextArray.idsSorted)) {\n      replace.add(key);\n      continue;\n    }\n\n    if (nextArray.noIdCount < prevArray.noIdCount) {\n      replace.add(key);\n    }\n  }\n\n  let normalizedOption = option;\n  let signature = next;\n\n  if (overrides.size > 0) {\n    const clone = { ...(option as Record<string, unknown>) };\n    overrides.forEach((value, key) => {\n      clone[key] = value;\n    });\n    normalizedOption = clone as Option;\n    signature = buildSignature(normalizedOption);\n  }\n\n  const replaceMerge =\n    replace.size > 0 ? Array.from(replace).sort() : undefined;\n\n  const plan = replaceMerge\n    ? { notMerge: false, replaceMerge }\n    : { notMerge: false };\n\n  return {\n    option: normalizedOption,\n    signature,\n    plan,\n  };\n}\n", "export default \"x-vue-echarts{display:block;width:100%;height:100%;min-width:0;}\\nx-vue-echarts>:first-child,x-vue-echarts>:first-child>canvas{border-radius:inherit;}\\n\"", "import cssRules from \"./style.css?raw\";\n\nif (typeof document !== \"undefined\") {\n  if (\n    Array.isArray(document.adoptedStyleSheets) &&\n    \"replaceSync\" in CSSStyleSheet.prototype\n  ) {\n    const sheet = new CSSStyleSheet();\n    sheet.replaceSync(cssRules);\n    document.adoptedStyleSheets = [...document.adoptedStyleSheets, sheet];\n  } else {\n    const styleEl = document.createElement(\"style\");\n    styleEl.textContent = cssRules;\n    document.head.appendChild(styleEl);\n  }\n}\n", "import {\n  defineComponent,\n  shallowRef,\n  toRefs,\n  watch,\n  computed,\n  inject,\n  onMounted,\n  onBeforeUnmount,\n  h,\n  nextTick,\n  watchEffect,\n  toValue,\n} from \"vue\";\nimport { init as initChart } from \"echarts/core\";\nimport type { EChartsOption } from \"echarts\";\n\nimport {\n  usePublicAPI,\n  useAutoresize,\n  autoresizeProps,\n  useLoading,\n  loadingProps,\n  useSlotOption,\n} from \"./composables\";\nimport type { PublicMethods, SlotsTypes } from \"./composables\";\nimport { isOn, omitOn, warn } from \"./utils\";\nimport { register, TAG_NAME } from \"./wc\";\nimport { planUpdate } from \"./update\";\nimport type { Signature, UpdatePlan } from \"./update\";\n\nimport type { PropType, InjectionKey } from \"vue\";\nimport type {\n  EChartsType,\n  SetOptionType,\n  Option,\n  Theme,\n  ThemeInjection,\n  InitOptions,\n  InitOptionsInjection,\n  UpdateOptions,\n  UpdateOptionsInjection,\n  Emits,\n} from \"./types\";\nimport type { EChartsElement } from \"./wc\";\n\nimport \"./style.ts\";\n\nconst wcRegistered = register();\n\nexport const THEME_KEY: InjectionKey<ThemeInjection> = Symbol();\nexport const INIT_OPTIONS_KEY: InjectionKey<InitOptionsInjection> = Symbol();\nexport const UPDATE_OPTIONS_KEY: InjectionKey<UpdateOptionsInjection> =\n  Symbol();\nexport { LOADING_OPTIONS_KEY } from \"./composables\";\n\nexport default defineComponent({\n  name: \"Echarts\",\n  inheritAttrs: false,\n  props: {\n    option: Object as PropType<Option>,\n    theme: {\n      type: [Object, String] as PropType<Theme>,\n    },\n    initOptions: Object as PropType<InitOptions>,\n    updateOptions: Object as PropType<UpdateOptions>,\n    group: String,\n    manualUpdate: Boolean,\n    ...autoresizeProps,\n    ...loadingProps,\n  },\n  emits: {} as unknown as Emits,\n  slots: Object as SlotsTypes,\n  setup(props, { attrs, expose, slots }) {\n    const root = shallowRef<EChartsElement>();\n    const chart = shallowRef<EChartsType>();\n    const defaultTheme = inject(THEME_KEY, null);\n    const defaultInitOptions = inject(INIT_OPTIONS_KEY, null);\n    const defaultUpdateOptions = inject(UPDATE_OPTIONS_KEY, null);\n\n    const { autoresize, manualUpdate, loading, loadingOptions } = toRefs(props);\n\n    const realTheme = computed(() => props.theme || toValue(defaultTheme));\n    const realInitOptions = computed(\n      () => props.initOptions || toValue(defaultInitOptions) || undefined,\n    );\n    const realUpdateOptions = computed(\n      () => props.updateOptions || toValue(defaultUpdateOptions),\n    );\n    const nonEventAttrs = computed(() => omitOn(attrs));\n    const nativeListeners: Record<string, unknown> = {};\n\n    const listeners: Map<{ event: string; once?: boolean; zr?: boolean }, any> =\n      new Map();\n\n    const { teleportedSlots, patchOption } = useSlotOption(slots, () => {\n      if (!manualUpdate.value && props.option && chart.value) {\n        applyOption(chart.value, props.option);\n      }\n    });\n\n    let lastSignature: Signature | undefined;\n\n    function resolveUpdateOptions(plan?: UpdatePlan): UpdateOptions {\n      const result: UpdateOptions = {};\n\n      const replacements = (plan?.replaceMerge ?? []).filter(\n        (key): key is string => key != null,\n      );\n      if (replacements.length > 0) {\n        result.replaceMerge = [...new Set(replacements)];\n      }\n\n      if (plan?.notMerge !== undefined) {\n        result.notMerge = plan.notMerge;\n      }\n\n      return result;\n    }\n\n    function applyOption(\n      instance: EChartsType,\n      option: Option,\n      override?: UpdateOptions,\n      manual = false,\n    ) {\n      const patched = patchOption(option);\n\n      if (manual) {\n        instance.setOption(patched, override ?? {});\n        lastSignature = undefined;\n        return;\n      }\n\n      if (realUpdateOptions.value) {\n        const updateOptions = override ?? realUpdateOptions.value;\n        instance.setOption(patched, updateOptions);\n        lastSignature = undefined;\n        return;\n      }\n\n      const planned = planUpdate(\n        lastSignature,\n        patched as unknown as EChartsOption,\n      );\n\n      const updateOptions = resolveUpdateOptions(planned.plan);\n      instance.setOption(planned.option, updateOptions);\n      lastSignature = planned.signature;\n    }\n\n    // We are converting all `on<Event>` props and collect them into `listeners` so that\n    // we can bind them to the chart instance later.\n    // For `onNative:<event>` props, we just strip the `Native:` part and collect them into\n    // `nativeListeners` so that we can bind them to the root element directly.\n    Object.keys(attrs)\n      .filter((key) => isOn(key))\n      .forEach((key) => {\n        // Collect native DOM events\n        if (key.indexOf(\"Native:\") === 2) {\n          // onNative:click -> onClick\n          const nativeKey = `on${key.charAt(9).toUpperCase()}${key.slice(10)}`;\n\n          nativeListeners[nativeKey] = attrs[key];\n          return;\n        }\n\n        // onClick    -> c + lick\n        // onZr:click -> z + r:click\n        let event = key.charAt(2).toLowerCase() + key.slice(3);\n\n        let zr: boolean | undefined;\n        if (event.indexOf(\"zr:\") === 0) {\n          zr = true;\n          event = event.substring(3);\n        }\n\n        let once: boolean | undefined;\n        if (event.substring(event.length - 4) === \"Once\") {\n          once = true;\n          event = event.substring(0, event.length - 4);\n        }\n\n        listeners.set({ event, zr, once }, attrs[key]);\n      });\n\n    function init() {\n      if (!root.value) {\n        return;\n      }\n\n      const instance = (chart.value = initChart(\n        root.value,\n        realTheme.value,\n        realInitOptions.value,\n      ));\n\n      if (props.group) {\n        instance.group = props.group;\n      }\n\n      listeners.forEach((handler, { zr, once, event }) => {\n        if (!handler) {\n          return;\n        }\n\n        const target = zr ? instance.getZr() : instance;\n\n        if (once) {\n          const raw = handler;\n          let called = false;\n\n          handler = (...args: any[]) => {\n            if (called) {\n              return;\n            }\n            called = true;\n            raw(...args);\n            target.off(event, handler);\n          };\n        }\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore EChartsType[\"on\"] is not compatible with ZRenderType[\"on\"]\n        // but it's okay here\n        target.on(event, handler);\n      });\n\n      function resize() {\n        if (instance && !instance.isDisposed()) {\n          instance.resize();\n        }\n      }\n\n      function commit() {\n        const { option } = props;\n\n        if (manualUpdate.value) {\n          if (option) {\n            applyOption(instance, option, undefined, true);\n          }\n          return;\n        }\n\n        if (option) {\n          applyOption(instance, option);\n        }\n      }\n\n      if (autoresize.value) {\n        // Try to make chart fit to container in case container size\n        // is changed synchronously or in already queued microtasks\n        nextTick(() => {\n          resize();\n          commit();\n        });\n      } else {\n        commit();\n      }\n    }\n    const setOption: SetOptionType = (\n      option,\n      notMerge,\n      lazyUpdate?: boolean,\n    ) => {\n      if (!props.manualUpdate) {\n        warn(\"`setOption` is only available when `manual-update` is `true`.\");\n        return;\n      }\n\n      const updateOptions =\n        typeof notMerge === \"boolean\" ? { notMerge, lazyUpdate } : notMerge;\n\n      if (!chart.value) {\n        return;\n      }\n\n      applyOption(chart.value, option, updateOptions ?? undefined, true);\n    };\n\n    function cleanup() {\n      if (chart.value) {\n        chart.value.dispose();\n        chart.value = undefined;\n      }\n      lastSignature = undefined;\n    }\n\n    watch(\n      () => props.option,\n      (option) => {\n        if (!option) {\n          lastSignature = undefined;\n          return;\n        }\n\n        if (manualUpdate.value) {\n          warn(\n            \"`option` prop changes are ignored when `manual-update` is `true`.\",\n          );\n          return;\n        }\n\n        if (!chart.value) {\n          return;\n        }\n\n        applyOption(chart.value, option);\n      },\n      { deep: true },\n    );\n\n    watch(\n      [manualUpdate, realInitOptions],\n      () => {\n        cleanup();\n        init();\n      },\n      {\n        deep: true,\n      },\n    );\n\n    watch(\n      realTheme,\n      (theme) => {\n        chart.value?.setTheme(theme || {});\n      },\n      {\n        deep: true,\n      },\n    );\n\n    watchEffect(() => {\n      if (props.group && chart.value) {\n        chart.value.group = props.group;\n      }\n    });\n\n    const publicApi = usePublicAPI(chart);\n\n    useLoading(chart, loading, loadingOptions);\n\n    useAutoresize(chart, autoresize, root);\n\n    onMounted(() => {\n      init();\n    });\n\n    onBeforeUnmount(() => {\n      if (wcRegistered && root.value) {\n        // For registered web component, we can leverage the\n        // `disconnectedCallback` to dispose the chart instance\n        // so that we can delay the cleanup after exsiting leaving\n        // transition.\n        root.value.__dispose = cleanup;\n      } else {\n        cleanup();\n      }\n    });\n\n    const exposed = {\n      setOption,\n      root,\n      chart,\n    };\n    expose({ ...exposed, ...publicApi });\n\n    // While `expose()` exposes methods and properties to the parent component\n    // via template refs at runtime, it doesn't contribute to TypeScript types.\n    // This type casting ensures TypeScript correctly types the exposed members\n    // that will be available when using this component.\n    return (() =>\n      h(\n        TAG_NAME,\n        {\n          ...nonEventAttrs.value,\n          ...nativeListeners,\n          ref: root,\n          class: [\"echarts\", nonEventAttrs.value.class],\n        },\n        teleportedSlots(),\n      )) as unknown as typeof exposed & PublicMethods;\n  },\n});\n", "import ECharts from \"./ECharts\";\n\nexport default ECharts;\nexport * from \"./ECharts\";\n"],
  "mappings": "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",
  "names": ["root", "chart", "autoresize", "ro: ResizeObserver | null", "LOADING_OPTIONS_KEY: InjectionKey<LoadingOptionsInjection>", "result: Attrs", "warn", "cur: Record<string, unknown> | undefined", "slotNames: SlotName[]", "registered: boolean | null", "arrays: Record<string, ArraySummary | undefined>", "objects: string[]", "scalars: string[]", "missing: string[]", "cssRules", "THEME_KEY: InjectionKey<ThemeInjection>", "INIT_OPTIONS_KEY: InjectionKey<InitOptionsInjection>", "UPDATE_OPTIONS_KEY: InjectionKey<UpdateOptionsInjection>", "nativeListeners: Record<string, unknown>", "listeners: Map<{ event: string; once?: boolean; zr?: boolean }, any>", "lastSignature: Signature | undefined", "result: UpdateOptions", "updateOptions", "zr: boolean | undefined", "once: boolean | undefined", "init", "initChart", "setOption: SetOptionType", "ECharts"]
}
